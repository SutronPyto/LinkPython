""" Test code for solar position
Checks position values generated by custom code against pvlib
should be run on PC"""

import random
import pvlib
import pandas as pd
from solar_position import solar_pos_ephemeris
from datetime import timedelta, datetime, timezone
import time


def random_geolocation():
    """Generate random latitude and longitude."""
    lat = random.uniform(-90, 90)  # Latitude between -90 and 90
    long = random.uniform(-180, 180)  # Longitude between -180 and 180
    return lat, long


def random_time():
    """Generate random time"""
    range_sec = (24 * 60 * 60) * 3000  # 3000 days
    second_random = random.randint(-range_sec, range_sec)
    random_datetime = datetime.now(timezone.utc) - timedelta(seconds=second_random)
    return random_datetime


itero = 0
count_fail = 0
largest_error = 0
error_limit = 0.05
key_mismatch = False


def test_solar(date_time_utc, lat, long, verbose, ephemeris_not_get_solarposition):
    global itero, largest_error, error_limit, count_fail, key_mismatch

    if ephemeris_not_get_solarposition:
        # get results from pvlib ephemeris
        dt_index = pd.DatetimeIndex([date_time_utc])
        e_og = pvlib.solarposition.ephemeris(dt_index, lat, long)
        e_og_dict = e_og.iloc[0].to_dict()  # Convert the first column to a dictionary
    else:
        # Get results from pvlib
        location = pvlib.location.Location(lat, long, 'UTC', 0)
        solar_position_pvlib = location.get_solarposition(date_time_utc)
        # convert to ephemeris output
        e_og_dict = {
            'apparent_elevation': solar_position_pvlib['apparent_elevation'].iloc[0],
            'elevation': solar_position_pvlib['elevation'].iloc[0],
            'azimuth': solar_position_pvlib['azimuth'].iloc[0],
            'apparent_zenith': solar_position_pvlib['apparent_zenith'].iloc[0],
            'zenith': solar_position_pvlib['zenith'].iloc[0],
        }

    # Get results from custom ephemeris
    # we must operate in utc time lest DST mess up the equation
    time_stamp = time.mktime(date_time_utc.timetuple())
    e_cus = solar_pos_ephemeris(time_stamp, lat, long)

    if verbose:
        print(f"Test {itero + 1}: Location ({lat:.2f}, {long:.2f}), Time: {date_time_utc}")

    # we should have the same keys in both dictionaries
    # Check each key and compare values
    match = True
    for key in e_og_dict:
        if key == 'solar_time':
            if not ephemeris_not_get_solarposition:
                continue  # location.get_solarposition does not do solar_time

        if key in e_cus:
            diff = abs(e_og_dict[key] - e_cus[key])
            if diff > error_limit:
                print(f"Value mismatch for key {key}: original ephemeris has {e_og_dict[key]}, custom has {e_cus[key]}")
                match = False
                if largest_error < diff:
                    largest_error = diff
            elif verbose:
                print(f"{key}: original {e_og_dict[key]:.2f}, custom  {e_cus[key]:.2f}")
        else:
            print(f"Key {key} found in original but not in custom.")
            key_mismatch = True
            match = False

    if verbose:
        if match:
            print("All values match")
        print()


def run_tests(number_of_tests=100, verbose=True, ephemeris_not_get_solarposition=True):
    print("Testing solar calc...")
    # test this specific case
    latitude = 40
    longitude = 105
    date_time = datetime(2024, 9, 5, 19, 50, 35)
    test_solar(date_time, latitude, longitude, verbose, ephemeris_not_get_solarposition)

    # run multiple random tests
    global itero
    for itero in range(number_of_tests):
        latitude, longitude = random_geolocation()
        date_time = random_time()
        test_solar(date_time, latitude, longitude, verbose, ephemeris_not_get_solarposition)
        if key_mismatch:
            break

    print("Tests run: " + str(number_of_tests))

    if key_mismatch:
        print("\nProgramming error.  Keys mismatch.")
    else:
        if count_fail:
            print("\nDiffernces: " + str(count_fail) + " (larger than " + str(error_limit) + ")")
            print("largest error " + str(largest_error))
        else:
            print("\nNo Differnces " + " (larger than " + str(error_limit) + ")")


run_tests(10000, False, True)  # run this many random tests
